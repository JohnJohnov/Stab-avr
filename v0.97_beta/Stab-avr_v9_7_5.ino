//Регулятор ТЭНа полуволнами с программным детектором нуля
//--https://github.com/JohnJohnov/Stab-avr
//--https://alcodistillers.ru/forum/viewtopic.php?id=1549
//--JohnJohnov-----------------------
//--использован код OldBean----------
//--v0.2-------------------
//--добавлен дисплей
//--v0.3-------------------
//--ПИД-подстройка частоты сети по переходу через ноль
//--опрос кнопок
//--режим разгона
//--v0.4-------------------
//--выборки набираются за целое количество периодов
//--v0.5-------------------
//--оптимизация
//--v0.6-------------------
//--организована корректная обработка отсутствия сети
//--v0.7-------------------
//--исправлена ошибка выставления мощности менее 200Вт
//--битовые переменные упакованы в структуры
//--убрано ненужное мерцание символов на дисплее
//--добавлена возможность вернуть установленную мощность после экстренного отключения (идея d.styler)
//--v0.8-------------------
//--менюшка при возвращении уст.мощности после экстр.откл.
//--v0.81------------------
//--сделано выравнивание значений по правому краю
//--перекомпонован дежурный экран 
//--выводится установленная мощность в Вт и процентах
//--напряжение сети выводится с одним знаком после запятой
//--v0.9-------------------
//--оптимизация кода
//--переход на более другую библиотеку дисплея
//--русский шрифт
//--номинальная мощность устанавливается/записывается/выбирается в начальном меню
//--уставки, выбираемые в меню после экстр.откл., могут быть записаны в EEPROM
//--v0.95------------------
//--исправлены ошибки
//--значение задержки для защиты от дребезга вынесено в дефайны
//--v0.96------------------
//--исправлены ошибки, оптимизирован код
//--расширены границы диапазона сетевой частоты для поддержки канадского коллеги
//--добавлена поддержка универсального протокола общения с управляющей программой
//--v0.97------------------
//--добавлена поддержка протокола общения с Samovar (начало посылки кириллицей)
//--добавлено моргание светодиода в отладочных целях
//--добавлен таймаут менюшек
//--добавлена поддержка протокола общения с РМВ-К
//--логотип
//--оптимизация кода
//--
//-------------------------
#include <Wire.h>
//#include <EEPROM.h>
//#include <avr/eeprom.h>
#include <ASOLED.h>
//
#define VERSION "v0.97"   // Версия скетча
#define VERSION_LEN 5     // Длина версии скетча в символах для правильного вывода на дисплей
#define LOGO              // Раскомментить для отображения логотипа
//
#ifdef LOGO
  #include "logo.c"
#endif
//
//========================================
//=====Настраиваемые параметры============
//========================================
//#define Debug           // Раскомментить для дебажения
//#define LED_debug       // Раскомментить для вывода на светодиод сигнала управления твердотельным реле
#define High_level_triac  // Раскомментить, если твердотельное реле ТЭНа управляется ВЫСОКИМ уровнем, иначе НИЗКИМ
#define High_level_relay  // Раскомментить, если контактное реле ТЭНа управляется ВЫСОКИМ уровнем, иначе НИЗКИМ
//#define NOT_LM358       // Раскомментить, если в датчике напряжения стоит НЕ LM358, а rail-to-rail операционник
#define DisplayReset      // Раскомментить, если используется вывод сброса дисплея
#define DEBOUNCE 26       // Значение для обеспечения защиты от дребезга кнопок DEBOUNCE=1 + <задержка в ms>/10
//
#define PSUM_MAX 50       // Количество периодов для набора отсчетов АЦП (50 - это за 1 сек, это порядка 5000 отсчетов)
#define ZSUM_MAX 5000     // Количество отсчетов АЦП без детекции ноля (5000 отсчетов это порядка 1 сек)
#define P_TIME_MAX 100    // Количество полупериодов сети в секунду для отсчета времени
//
#define U_LINE 230        // Номинальное значение действующего напряжения в сети, для которого указана номинальная мощность ТЭНа
#define U_MIN 100         // Значение напряжения в сети, ниже которого сеть считается аварийной
#define U_LINE_Q 52900    // Квадрат номинала сети, для которого указана номинальная мощность ТЭНа
//
#define MENU_TIMEOUT 120  // Таймаут выхода из меню в секундах (не более 255)
//
//=====Настройки коммуникации по последовательному порту============
//#define USE_USART       // Раскомментить для инициализации общения стаба с внешним контроллером 
  #ifdef USE_USART        //
  //
  //#define USE_RMVK      // Раскомментить для включения общения с внешним контроллером по протоколу Samovar и/или РМВ-К
  //
    #ifndef USE_RMVK      //
    #define USE_ADprotocol// По умолчанию используется универсальный протокол
    #endif
  #endif
//========================================
//
#define OLED_newADDRESS    (0x3C)   //Дисплей OLED 128х64
//
#define pin_VACin 0       //  Пин входа измеряемого напряжения (A0)
#define pin_OLED_res 2    //  Пин сброса OLED индикатора.
#define pin_TOut 4        //  Пин выхода управления ТЭНом (на твердотельное реле)
#define pin_TRelay 6      //  Пин выхода управления ТЭНом (на контактное реле в режиме максимальной мощности)
#define pin_ZeroOut 5     //  Пин выхода импульса ноля
#define pin_DebugOut 7    //  Пин для отладки
#define pin_TestOut 3     //  Пин для отладки

//
#define pin_butt_1 10     // Пин кнопки "Р-". Уменьшение уставки мощности.
#define pin_butt_2 9      // Пин кнопки "Р+". Увеличение уставки мощности.
#define pin_butt_3 12     // Пин кнопки "Стоп". Экстренное отключение ТЭНа.
#define pin_butt_4 11     // Пин кнопки "Разгон". Включение/отключение разгона.
#define pin_buttGND 8     // Пин временного общего провода для подключения кнопок.
//
#define U_ZERO 512              // Значение нуля АЦП для двуполярного сигнала с постоянной составляющей на выходе ОУ
#define LINE_FREQ 155           // Определяет начальную частоту для фазовой автоподстройки частоты сети (50,08Гц)
#define T_ADC 49                // Определяет интервал между запусками АЦП (200 мкс)
//f_OCn = f_clk / 2*N*(1 + X), где N - коэффициент деления предделителя, X- содержимое регистра OCRnA
#define CICLE 200               // Количество полупериодов в полном цикле регулирования (200 полупериодов - 2сек, если устанавливать более 255 - надо менять размерность сопутствующих переменных )
//
#define Kp 1      // Коэффициент пропорциональности для ПИД-подстройки ФЧ сети (степень двойки для регистрового сдвига)
#define Ki 5      // Интегральный коэффициент для ПИД-подстройки ФЧ сети (степень двойки для регистрового сдвига)
#define Kd 2      // Дифференциальный коэффициент для ПИД-подстройки ФЧ сети (степень двойки для регистрового сдвига)
#define Km 6      // Коэффициент для целочисленной математики (степень двойки для регистрового сдвига)
#define Phase 8   // сдвиг фаз между детекцией ноля и прерыванием таймера (в тиках таймера)
#define T_max 200 // ограничение максимальной длительности полупериода в тиках таймера
#define T_min 100 // ограничение минимальной длительности полупериода в тиках таймера
//
static uint16_t Pnom;             // Номинальная мощность ТЭНа (хранится в EEPROM и устанавливается из менюшки)
#define Pnom_ARRAY_SIZE 8         // Макс. размер массива записанных номинальных мощностей ТЭНа sizeof(Pnom_arr)/sizeof(Pnom_arr[0])
static uint16_t Pnom_arr[Pnom_ARRAY_SIZE];  // Массив мощностей ТЭНа
#define PDMset_SIZE 6             // Размер массива уставок мощности ТЭНа sizeof(PDMset)/sizeof(PDMset[0]) (ставить не меньше 4)
static uint16_t PDMset[2][PDMset_SIZE] = {CICLE/5,2*CICLE/5,CICLE/2,3*CICLE/5,4*CICLE/5,CICLE}; // Массив уставок мощности ТЭНа
//
// В EEPROM хранятся значения номинальных мощностей ТЭНа (8 значений в первых 16 байтах, определяется величиной Pnom_ARRAY_SIZE)
// и уставки мощности для каждой номинальной в формате pdm (занимает 1 байт),
// уставки пишутся не в конкретные ячейки, а по кругу до заполнения выделенного участка EEPROM.
// Так сделано для экономии ресурса EEPROM
#define EEPROM_SIZE 1024                // Значение емкости EEPROM в байтах (1024 для Arduino NANO)
static volatile uint16_t old_addr = 0;  // Адрес в EEPROM, где записана самая старая уставка
static volatile uint16_t new_addr = 0;  // Адрес в EEPROM, куда писать новую уставку
static volatile uint16_t start_addr = 0;// Начальный адрес области записи уставок в EEPROM
static volatile uint16_t end_addr = 0;  // Конечный адрес области записи уставок в EEPROM
static volatile uint16_t clear_old_addr;// Дубль адреса в EEPROM, где записана самая старая уставка, предназначенная для стирания
//
static volatile uint32_t sum;               // Сумматор квадратов отсчетов АЦП
static volatile uint16_t sc = 0;            // Счетчик просуммированных квадратов
static volatile uint16_t sc_sum = 0;        // Счетчик просуммированных квадратов, готовый к обработке
static volatile uint16_t sc_notzero = 0;    // Счетчик выборок АЦП без перехода через ноль
static volatile uint8_t  pdm = 0;           // Текущий уровень PDM (принимает значения от 0 до CICLE)
static volatile uint32_t Pust = 0;          // Установленная мощность ТЭНа
static volatile uint8_t PDMust = 0;         // PDM, соответствующий установленной мощности ТЭНа
//
static volatile uint32_t U_sum = 0;         // Среднеквадратичное в сети за секунду, умноженное на 10
static uint16_t U_real = sqrt(U_LINE_Q);    // Среднеквадратичное за секунду (целая часть)
static uint8_t U_real_dec = 0;              // Среднеквадратичное за секунду (дробная часть)
//
static volatile int16_t Uold = 0;           // Буферная переменная для НЧ-фильтрации
static volatile int32_t Udelta = 0;         // Буферная переменная для НЧ-фильтрации
static volatile int16_t lev = 0, err = 0;   // Буферные переменные для реализации PDM методом диффузии (смещения) ошибки
static volatile int8_t ps = 0;              // Буферная переменная для реализации PDM методом диффузии (смещения) ошибки
//
static volatile uint8_t PID_ust = LINE_FREQ;        // Данные для установки регистра сравнения таймера2
static volatile uint16_t PID_reg = PID_ust << Km;   // Функция управления ПИД
static volatile int32_t PID_err_old = 0;            // Разность фаз из предыдущего шага
static volatile int32_t PID_int = 0;                // Интегральная составляющая из предыдущего шага
//
// Организуем флаги и индикаторы в структуру
static volatile struct flags {
  unsigned  zero : 1;         // Флаг перехода через ноль
  unsigned  PP : 1;           // Флаг начала очередного полупериода
  unsigned  PVolna : 1;       // Флаг полуволны ((отрицательная = 0, положительная = 1)
  unsigned  sum : 1;          // Флаг готовности насуммированных данных к обработке
  unsigned  Tout : 1;         // Флаг включения ТЭНа (твердотельное реле)
  unsigned  TRelay : 1;       // Флаг включения ТЭНа (контактное реле)
  unsigned  Ulow : 1;         // Флаг невозможности выдать установленный уровень мощности
  unsigned  Udown : 1;        // Флаг аварии сети (действующее напряжение ниже 100В)
  unsigned  NotZero : 1;      // Флаг аварии сети (не детектируются переходы через ноль)
  unsigned  razg : 1;         // Флаг режима "разгон"
  unsigned  razg_on : 1;      // Флаг начала режима "разгон"
  unsigned  butt : 1;         // Флаг опроса кнопок
  unsigned  writable : 1;     // Флаг записи уставок в EEPROM
  unsigned  DisplayOut : 1;   // Флаг вывода на дисплей обновленных данных
  unsigned  dspRefresh : 1;   // Флаг выхода из режима меню / обновления экрана
  unsigned  dspTimeout : 1;   // Флаг истечения времени ожидания выхода из меню
  unsigned  dspMenu : 2;      // Индикатор режима меню
  unsigned  uartUnhold : 1;   // Флаг разрешения передачи данных по USART
  unsigned  uartReport : 1;   // Флаг разрешения отправки данных внешнему контроллеру
  unsigned  uartTimeout : 1;  // Флаг истечения времени приема посылки по USART
} fl = {};  // Инициализируем структуру с нулевыми членами
//
// Организуем счетчики в структуру
static volatile struct counts {
  unsigned  Pnom_count : 3;   // Количество предустановок мощности
  unsigned  Pnom_number : 3;  // Номер активной предустановки мощности
  unsigned  PDMcount : 3;     // Счетчик для перебора уставок мощности ТЭНа
  unsigned  Pcount_tm : 7;    // Счетчик полупериодов для организации отсчета времени
  unsigned  menuWDT : 8;      // Счетчик секунд для организации отсчета ожидания выхода из меню
  unsigned  PPcount_R : 6;    // Счетчик времени шунтирования контактного реле
  unsigned  uartWDT : 4;      // Счетчик секунд для организации отсчета ожидания окончания посылки по USART
} cnt = {}; // Инициализируем структуру с нулевыми членами
//
byte X_position (const byte x, const uint16_t arg = 1); // Функция возвращает начальную позицию по Х для десятичного числа, в зависимости от количества знаков в нём.
byte X_centred (const byte len);    // Функция возвращает начальную позицию по Х для текста длинной len знаков, для размещения оного по центру дисплея.
byte A_to_HEX (const char a);       // Функция переводит символ ASCII в шестнадцатиричную цифру
char HEX_to_A (const byte x);       // Функция переводит шестнадцатиричную цифру в символ ASCII
//ASOLED ASOled;
#define ASOled LD // Заюзаем уже созданный в библиотеке дисплея объект LD
//
//==============================================================================
//============================ПРОЦЕДУРЫ И ФУНКЦИИ===============================
//==============================================================================
//
// Функция возвращает начальную позицию по Х для десятичного числа, в зависимости от количества знаков в нём.
byte X_position (const byte x, const uint16_t arg) { // arg-выводимое число; х-позиция для arg, если бы оно было однозначно
  byte pix = 6; // Ширина шрифта в пикселях
  if (arg > 999) return pix * (x-3);
  else if (arg > 99) return pix * (x-2);
  else if (arg > 9) return pix * (x-1);
  else return pix * x;
}
//
// Функция возвращает начальную позицию по Х для текста длинной len знаков, для размещения оного по центру дисплея.
byte X_centred (const byte len) { // len - Количество знакомест в тексте
  byte wdt = 128; // Ширина дисплея в пикселях
  byte pix = 6;   // Ширина шрифта в пикселях
  if (len > wdt/pix) return 0;
  else return (wdt - (len * pix))/2;
}
//
// Функция переводит символ ASCII в шестнадцатиричную цифру, при ошибке возвращает 255
byte A_to_HEX (const char a) { // a - символ 0...F
  if (a >= 48 && a <= 57) { // Если а - от 0 до 9
    return byte(a-48);
  }
  else if (a >= 65 && a <= 70) { // Если а - от A до F
    return byte(a-55);
  }
  else if (a >= 97 && a <= 102) { // Если а - от a до f
    return byte(a-87);
  }
  else return 255;
}
//
// Функция переводит шестнадцатиричную цифру в символ ASCII, при ошибке возвращает X
char HEX_to_A (const byte x) {  // x - число, кое необходимо перевести в ASCII-код
  if (x <= 9) {
    return char(x + 48);
  }
  else if (x <= 15) {
    return char(x + 55);
  }
  else return 'X';
}
//
void set_Pust() { //===========Подпрограммка подсчета Pust================
  Pust = Pnom << 1; Pust *= PDMust; Pust /= CICLE;  Pust++; Pust = Pust >> 1; // Считаем Pust с округлением
} //===========Подпрограммка подсчета Pust================
//
void pp_Delay(const uint16_t pp) {  //===Пауза, измеряется в полупериодах=====
  uint16_t  PPcount = 0;            // счетчик полупериодов
  while (PPcount < pp) {
    if (fl.PP) {
      PPcount++;
      fl.PP = 0;
    }
  }
}
//
#ifdef USE_USART//++++++++++++++++USART initialization++++++++++++++++++++++++++++
//Если задействовано управление регулятором ТЭНа через UART, инициализируем оный
//
void USART_start() {
  Serial.begin(9600, SERIAL_8N1); // Инициализируем USART
  #ifdef Debug
  Serial.println("Started");
  #endif
}
//
uint16_t get_Power() {  // Функция возвращает значение текущей мощности с учетом режима "Разгон"
  if (fl.Udown || fl.NotZero) {     // Если сеть в дауне - передаем ноль
    return 0;
  }
  else if (fl.razg_on || fl.Ulow) { // В разгоне и при недостаточном сетевом передаем расчетную текущую мощность
    uint32_t tmp_u = U_sum * U_sum;
    tmp_u /= 100;
    tmp_u *= Pnom;
    tmp_u /= U_LINE_Q;
    return tmp_u;
  }
  else {                            // В рабочем режиме - передаем уставку
    return Pust;
  }
}
//
void set_newPDM(uint32_t power) { // Функция установки текущей мощности по запросу
  if (power >= Pnom) {  // Если параметр превышает максимально возможное значение,
    PDMust = CICLE; // значит ставим максимально возможное значение.
  }
  else {
    power *= CICLE;
    power *= 2;
    power /=Pnom;
    power++;
    power /= 2;
    PDMust = power;
  }
  //
  set_Pust();         // Посчитаем Pust
  fl.DisplayOut = 1;  // Обновление информации на дисплее
}
//
#endif // USE_USART
//
#ifdef USE_ADprotocol //++++++++++++++++USART++++++++++++++++++++++++++++
//
//Байт "состав данных" b00010111 (основной параметр - мощность в нагрузке, доп. параметр - напряжение сети) в HEX-формате 0x17
static char USART_InfoData[14] = {'T','1','7','0','0','0','0','0','0','0','0','0','0',0x0D};  // Массив готовых данных для передачи внешнему контроллеру
static char USART_SetData[6];  // Массив управляющих символов от внешнего контроллера
//
void USART_parser() { // Парсим управляющую последовательность по универсальному протоколу
  //
  static byte index = 0;
  static byte data_size;
//
  while (Serial.available() > 0) {
    if ( !index || fl.uartTimeout ) {   // Начало
      USART_SetData[0] = Serial.read(); // Вычитываем очередной байт
      fl.uartTimeout = 0;               // Сбросим флаг таймаута ожидания окончания посылки
      cnt.uartWDT = 0;                  // Сбросим таймер ожидания окончания посылки
      switch ( USART_SetData[0] ) {     // Ждём первый символ...
        case 'M':
        case 'm': {                     // ...запроса на изменение режима работы
          data_size = 2;
          index=1;
          break;
        }
        case 'P':
        case 'p': {                     // ...запроса на изменение уставки
          data_size = 5;
          index=1;
          break;
        }
        default: {
//          break;
        }
      }
    }
    else {
      USART_SetData[index] = Serial.read(); // Вычитываем очередной байт
      if ( USART_SetData[index] == 0x0D ) { // Ждем последнего символа посылки <CR>
        if ( index == data_size ) {
          switch (index) {
            case 2: { // Парсим запрос на смену режима
              switch ( USART_SetData[1] ) {
                case '0': { // Переход в рабочий режим
                  if ( fl.razg_on ) {
                    fl.razg_on = 0;
                    fl.TRelay = 0; 
                  }
                  break;
                }
                case '1': { // Переход в режим разгона
                  if ((!fl.NotZero) & (!fl.Udown)) {  // Если электросеть в дауне - не разгонишься
                      fl.razg_on = 1;
                      fl.razg = 1;
                  } 
                  break;
                }
                case '2': { // Отключение нагрузки
                  PDMust = 0;
                  fl.razg_on = 0;
                  fl.TRelay = 0; 
                  Pust = 0;
                  break;
                }
                default: {
                  break;
                }
              }
              break;
            }
            case 5: { // Парсим запрос на смену уставки
              uint32_t tmp_p = 0;
              byte b;
              for (byte x=1; x <= 4; x++ ) {
                tmp_p *= 16;
                b = A_to_HEX (USART_SetData[x]);
                if (b == 255) {
                  break;
                }
                tmp_p += b;
              }
              if (b != 255) {
                set_newPDM (tmp_p);   // Установим новую уставку мощности;
              }
              break;
            }
          }
        index = 0;
        }
        else index = 0;
      }
      else if ( index++ == data_size ) {
        index = 0;
      }
    }
  }
}
//
void USART_report() { //=====Отчет внешнему контроллеру по универсальному протоколу=====
  uint16_t b;
  //
  if (fl.Udown || fl.NotZero) {
    b = 6;  // b000001(10) - отсутствие сетевого напряжения, нагрузка отключена
  }
  else if (fl.razg_on) {
    b = 1;  // b(000000)(01) - разгон
  }
  else if (PDMust == 0) {
    b = 2;  // b000000(10) - нагрузка отключена
  }
  else if (fl.Ulow) {
    b = 8;   // b000010(00) - напряжения сети недостаточно для достижения уставки
  }
  else {
    b = 0;  // b000000(00) - режим рабочий, ошибок нет
  }
  // Закодируем состав данных
  USART_InfoData[3] = HEX_to_A ( b / 16 );  // Старший разряд байта "Режим + ошибки"
  USART_InfoData[4] = HEX_to_A ( b % 16 );  // Младший разряд байта "Режим + ошибки"
  //
  // Закодируем основной параметр - мощность на выходе
  b = get_Power();  // Получим текущую мощщу
  USART_InfoData[8] = HEX_to_A ( b % 16 );  // 0 разряд основного параметра
  b /= 16;
  USART_InfoData[7] = HEX_to_A ( b % 16 );  // 1 разряд основного параметра
  b /= 16;
  USART_InfoData[6] = HEX_to_A ( b % 16 );  // 2 разряд основного параметра
  USART_InfoData[5] = HEX_to_A ( b / 16 );  // 3 разряд основного параметра
  //
  // Закодируем доп.параметр - напряжение сети
  if (fl.NotZero) { // Если сети нет, то и на выходе пусто
    USART_InfoData[12] = '0'; // 0 разряд основного параметра
    USART_InfoData[11] = '0'; // 1 разряд основного параметра
    USART_InfoData[10] = '0'; // 2 разряд основного параметра
    USART_InfoData[9]  = '0'; // 3 разряд основного параметра
  }
  else {
    b = U_sum;
    USART_InfoData[12] = HEX_to_A ( b % 16 ); // 0 разряд основного параметра
    b /= 16;
    USART_InfoData[11] = HEX_to_A ( b % 16 ); // 1 разряд основного параметра
    b /= 16;
    USART_InfoData[10] = HEX_to_A ( b % 16 ); // 2 разряд основного параметра
    USART_InfoData[9]  = HEX_to_A ( b / 16 ); // 3 разряд основного параметра
  }
  // Отправим
  Serial.write(USART_InfoData, 14);
}
//
#endif  //+++++++++++++++++++++++USART++++++++++++++++++++++++++++
//
#ifdef USE_RMVK //++++++++++++++++RMVK_/_Samovar++++++++++++++++++++++++++++
uint16_t get_Uin() {     // Функция возвращает значение текущего напряжения без десятичного знака
  if (U_real_dec < 5) {
    return U_real;
  }
  else {
    return (U_real + 1);
  }
}
//
uint16_t get_Uout(boolean getReal) {  // Функция возвращает расчетное значение текущего (если getReal=true) или желаемого (если getReal=false) напряжения
  if ( fl.Udown || fl.NotZero || (PDMust == 0) ) {    // Если сеть в дауне или стаб в стопе - передаем ноль
    return 0;
  }
  else if ( getReal && ( fl.razg_on || fl.Ulow ) ) {  // В разгоне и при недостаточном сетевом передаем текущее сетевое, если надо
    return get_Uin();
  }
  else {    // В рабочем режиме - передаем уставку
    uint32_t tmp_u = PDMust;
    tmp_u *= 2;
    tmp_u *= U_LINE;
    tmp_u /= CICLE;
    tmp_u++;
    tmp_u /= 2; // Округлим
    return tmp_u;
  }
}
//
void USART_parser() { // Парсим управляющую последовательность от RMVK_/_Samovar
//
  static String inoutString;
  static byte index = 0;
//
  while (Serial.available() > 0) {
    char inChar = (char)Serial.read();// Вычитываем очередной байт
    if ( !index || fl.uartTimeout ) { // Начало посылки
      if ((inChar == 'A') || (byte(inChar) == 0xD0)) { // Ждём первый символ посылки "A" или первый байт UTF-кириллицы из протокола Samovar'a
        inoutString = inChar;
        index=1;
        fl.uartTimeout = 0; // Сбросим флаг таймаута ожидания окончания посылки
        cnt.uartWDT = 0;    // Сбросим таймер ожидания окончания посылки
      }
    }
    else if ( index++ < 13 ) {  // Пока посылка не длиннее 13 символов, считаем её корректной
      if ( inChar == 0x0D ) {   // Ждем последнего символа посылки <CR>
        index = 0;
        // Парсим строку, поскольку кончилась
        // В протоколе Samovar стандартное начало посылки "АТ" пересылается русскими символами в Юникоде. Баг или фича?
        if (( inoutString == F("AT+VI?")) ||  // Запрос текущего напряжения сети
            ( inoutString == F("АТ+VI?"))) {  // В этой строке "АТ" - русскими символами!
          if (fl.NotZero) { // Если сети нет, то и на выходе пусто
            inoutString = String(0);
          }
          else {
            inoutString = String(get_Uin());
          }
        }
        else if (( inoutString == F("АТ+VO?")) || ( inoutString == F("АТ+VS?"))) {  // Запрос текущей мощности от Samovar. В этой строке "АТ" - русскими символами!
          inoutString = String(get_Power());
        }
        else if ( inoutString == F("AT+VO?") ) {  // Запрос текущего напряжения на выходе от РМВ-К
          inoutString = String(get_Uout(true));
        }
        else if ( inoutString == F("AT+VS?") ) {  // Запрос напряжения уставки на выходе от РМВ-К
          inoutString = String(get_Uout(false));
        }
        else if (( inoutString == F("AT+SS?")) ||   // Запрос режима от Samovar
                ( inoutString == F("АТ+SS?"))) {    // В этой строке "АТ" - русскими символами!
          if (fl.Udown || fl.NotZero) {     // При сильно пониженном напряжении сети или его отсутствии - передаем ошибку
            inoutString = String(3);
          }
          else if (fl.razg_on) {            // Передаем "Разгон"
            inoutString = String(1);
          }
          else if (PDMust == 0) {           // Передаем "Стоп"
            inoutString = String(2);
          }
          else {                            // Передаем "Рабочий режим"
            inoutString = String(0);
          }
        }
        else if (( inoutString == F("AT+ON=0")) ||  // Запрос на выключение стабилизатора
                ( inoutString == F("АТ+ON=0"))) {   // В этой строке "АТ" - русскими символами!
          PDMust = 0;
          fl.razg_on = 0;     //выключим режим разгона
          fl.TRelay  = 0;     //выключим контактное реле
          Pust = 0;
          fl.DisplayOut = 1;  //Обновление информации на дисплее
          inoutString = "";
        }
        else if (( inoutString == F("AT+ON=1")) ||  // Запрос на включение режима "Разгон"
                ( inoutString == F("АТ+ON=1"))) {   // В этой строке "АТ" - русскими символами!
          if ((!fl.NotZero) & (!fl.Udown)) {        // Если электросеть не в дауне, то включим
            fl.razg_on = 1;
            fl.razg = 1;
            fl.DisplayOut = 1;  //Обновление информации на дисплее
          }
          inoutString = "";
        }
        else if ( inoutString == F("AT+ON?") ) {              // Запрос состояния выхода от РМВ-К
          if ((PDMust == 0) || (fl.NotZero) || (fl.Udown)) {  // Если на выходе 0
            inoutString = String("OFF");
          }
          else {
            inoutString = String("ON");
          }
        }
        else if ( inoutString.substring(0,8) == F("АТ+VS=") ) {  // Запрос на изменение уставки от Samovar. В этой строке "АТ" - русскими символами!
          //выключаем разгон, на всякий случай
          fl.razg_on = 0;     // выключим режим разгона
          fl.TRelay  = 0;     // выключим контактное реле
          set_newPDM (inoutString.substring(8).toInt());        // Установим новую уставку мощности
          inoutString = "";
        }
        else if ( inoutString.substring(0,6) == F("AT+VS=") ) { // Запрос на изменение уставки от РМВ-К
          if (fl.Udown || fl.NotZero) {  // Если сеть в дауне - ничего не меняем, передаем ошибку
            inoutString = String(F("error"));
          }
          else {
            uint16_t tmp_u = inoutString.substring(6).toInt();
            if ( tmp_u < U_LINE ) {
              tmp_u *= CICLE;
              PDMust = tmp_u / U_LINE;
            }
            else PDMust = CICLE;
            //выключаем разгон, на всякий случай
            fl.razg_on = 0;     // выключим режим разгона
            fl.TRelay  = 0;     // выключим контактное реле
            set_Pust();         // Посчитаем Pust
            fl.DisplayOut = 1;  // Обновление информации на дисплее
            inoutString = String(get_Uout(false));
          }
        }
        else {  // Неизвестная или закосяченная команда
          #ifdef Debug
            inoutString = String(F("(o_O unknown!)"));
          #else
            inoutString = "";
          #endif
        }
        // 
        if ( inoutString != "" )  {       // Если строка не пустая
            inoutString += char(0x0D);    // Добавляем в конец <CR>
            Serial.print( inoutString );  // Шлём!
        }
      }
      else {  // Еще не конец
        inoutString += inChar;  // Добавляем и это лыко в строку
      }
    }
    else {  // Посылка длинновата, а значит - некорректна, начинаем сначала
      index = 0;
    }
  }
}
//
#endif  //+++++++++++++++++++++++RMVK_/_Samovar++++++++++++++++++++++++++++
//
void EEPROM_read_Pnoms() { //===========Подпрограмма чтения начальных данных из EEPROM================
//
  for (cnt.Pnom_count = 0; cnt.Pnom_count < Pnom_ARRAY_SIZE; cnt.Pnom_count++) {
    Pnom_arr[cnt.Pnom_count] = eeprom_read_word((uint16_t*)(cnt.Pnom_count * 2));
//    cnt.Pnom_count = x;
    if (Pnom_arr[cnt.Pnom_count] == 0xffff) { // Дошли до пустой ячейки
      break;
    }
    Pnom = Pnom_arr[cnt.Pnom_number]; // По умолчанию установим номинальную мощность из первой ячейки
  }
}//===========Подпрограмма чтения начальных данных из EEPROM================
//
void EEPROM_read_PDMs() { //===========Подпрограмма чтения уставок из EEPROM для выбранной Pnom================
//
  uint16_t PDMtmp[2][PDMset_SIZE] = {0};
  uint8_t tmpcount = 0; uint16_t x;
  x = (EEPROM_SIZE - 2 * Pnom_ARRAY_SIZE)/(Pnom_ARRAY_SIZE);  // Размер области для записи уставок в EEPROM
  start_addr = Pnom_ARRAY_SIZE * 2 + cnt.Pnom_number * x;     // Начальный адрес области
  end_addr = start_addr + x - 1;                              // Конечный адрес области
  //
  //---Дальше пытаемся читать запомненные значения, они должны быть расположены подряд---
  //
  uint16_t read_region_end_addr = end_addr;                   // Адрес ячейки, на которой чтение можно окончить
  uint8_t y = eeprom_read_byte((uint8_t*)end_addr);           // Прочтем последнюю ячейку области
  if (y != 0xff) {                                            // Если считанное значение не пустое, то
    read_region_end_addr = start_addr + PDMset_SIZE - 3;      // На 3 меньше, потому что одно значение уже есть, как минимум, другое в память не пишется, ну и размер на единицу больше наибольшего индекса, Так-то!
    for (x = end_addr + 2 - PDMset_SIZE; x <= end_addr; x++) {// Почитаем из области для записи уставок в EEPROM, начиная с конца
      y = eeprom_read_byte((uint8_t*)x);
      if (y != 0xff) {                                        // Если считанное значение не пустое, то
        PDMtmp[0][tmpcount] = y;                              // запишем его в массив уставок
        PDMtmp[1][tmpcount] = x;                              // и туда же запишем адрес значения в памяти EEPROM
        if (++tmpcount > PDMset_SIZE-2) break;                // Закончим, заполнив массив
      }
    }
  }
  if (tmpcount < PDMset_SIZE - 1) {                           // Проверим массив уставок на заполненность и если не полон, то
    for (x = start_addr; x <= read_region_end_addr; x++) {    // Почитаем ещё из области для записи уставок в EEPROM, начиная с начала
      y = eeprom_read_byte((uint8_t*)x);
      if (y != 0xff) {                                        // Если считанное значение не пустое, то
        PDMtmp[0][tmpcount] = y;                              // запишем его в массив уставок
        PDMtmp[1][tmpcount] = x;                              // и туда же запишем адрес значения в памяти EEPROM
        if (++tmpcount > PDMset_SIZE-2) break;                // Закончим, заполнив массив
      }
    }
  }
  //
  //---Прочитали---
  //
  if (tmpcount) { // Если записанные уставки есть, то...
    tmpcount--;   // Декрементируем счетчик, чтобы индексы начинались с нуля
    new_addr = PDMtmp[1][tmpcount];                   // Адрес для записи новой уставки...
    if (++new_addr > end_addr) new_addr = start_addr; // на единицу больше адреса последней считанной, но не больше границы области
    if (tmpcount == PDMset_SIZE-2) {  // Если массив полон
      old_addr = PDMtmp[1][0]; // то адрес самой старой уставки в нулевой ячейке
    }
    { // Уберем дублирующиеся значения
      uint8_t PDMdiff[PDMset_SIZE] = {0};   // Заведем временный массив совпадений
      for (x = 0; x < PDMset_SIZE; x++) {   // Пробежимся по обоим массивам
        for (int y = 0; y <= tmpcount; y++) {
          if (PDMset[0][x] == PDMtmp[0][y]) ++PDMdiff[x]; // И заполним массив совпадений
        }
      }
      for (x = 0; x < PDMset_SIZE - 1; x++) { // Сортируем
        for (int y = x + 1; y < PDMset_SIZE; y++) {
          if (PDMdiff[y]) {             // Если в данной позиции есть совпадение
            uint8_t z = PDMset[0][x];
            PDMset[0][x] = PDMset[0][y];// Обмениваемся
            PDMset[0][y] = z;
            PDMdiff[y] = PDMdiff[x];
            break;
          }
        }
      }
    }
    for (x = 0; x <= tmpcount; x++) { // Допишем в рабочий массив считанное из EEPROM
      PDMset[0][x] = PDMtmp[0][x];
      PDMset[1][x] = PDMtmp[1][x];
    }
  }
  else {          // Записанных уставок нет
    new_addr = start_addr;  // Адрес для записи новой уставки равен начальному
  }
}//===========Подпрограмма чтения уставок из EEPROM для выбранной Pnom================
//
void ADC_init() { //===============Инициализация АЦП===================
  ADMUX = 0;
  ADMUX |= ( 1 << REFS0);  // Задаем ИОН равный напряжению питания
  ADMUX |= (0 & 0x07);    // Выбираем пин A0 для преобразования
  ADCSRA |= (1 << ADPS2 ) | (1 << ADPS1) | (1 << ADPS0); // предделитель на 128
  ADCSRA |= (1 << ADIE);  // Разрешаем прерывания по завершении преобразования
  ADCSRA |= (1 << ADEN);  // Включаем АЦП
}//================================Инициализация АЦП===================
//
void Timers_init() { //===============Инициализация таймеров===================
  //---Инициализация таймера 0 для тактирования АЦП -------------
  TCCR0A = 0;
  TCCR0B = 0;
  TCCR0A |= (1 << WGM01); // Счетчик работает в режиме CTC (сброс по совпадению)
  TCCR0B |= (1 << CS01) | (1 << CS00); // Предделитель на 64 (на счетчик - 250 кГц)
  OCR0A = T_ADC; // Определяет период запуска АЦП
  TIMSK0 |= (1 << OCIE0A); // Разрешаем прерывания по совпадению с OCR0A
  // Инициализация таймера 2 для формирования импульса нуля Zero
  TCCR2A = 0;
  TCCR2B = 0;
  TCCR2A |= (1 << WGM21); // Счетчик работает в режиме CTC (сброс по совпадению)
  TCCR2B |= (1 << CS22) | (1 << CS21) | (1 << CS20); // Предделитель на 1024 (сч. - 15.625 кГц/64мкс)
  OCR2A = LINE_FREQ; // Прерывание с удвоенной частотой сети
  TIMSK2 |= (1 << OCIE2A); // Разрешаем прерывания по совпадению с OCR2A
}//=================================Инициализация таймеров===================
//
void Pins_init() { //======Инициализация входов/выходов контроллера=========
#ifdef DisplayReset
  pinMode(pin_OLED_res, OUTPUT);      // Определяем вывод сброса дисплея, как выход
  digitalWrite(pin_OLED_res, LOW);    // Сбрасываем дисплей (!!! НЕ ЗАБЫТЬ ПЕРЕКЛЮЧИТЬ НА ВЫСОКИЙ !!!)
#endif
  pinMode(pin_TOut, OUTPUT);          // Определяем вывод твердотельного реле, как выход
  pinMode(pin_TRelay, OUTPUT);        // Определяем вывод контактного реле, как выход
#ifdef High_level_triac // управление высоким уровнем
  digitalWrite(pin_TOut, LOW);        // Выключаем ТЭН (твердотельное реле)
#else // управление низким уровнем
  digitalWrite(pin_TOut, HIGH);       // Выключаем ТЭН (твердотельное реле)
#endif
#ifdef High_level_relay // управление высоким уровнем
  digitalWrite(pin_TRelay, LOW);        // Выключаем ТЭН (контактное реле)
#else // управление низким уровнем
  digitalWrite(pin_TRelay, HIGH);       // Выключаем ТЭН (контактное реле)
#endif
  //
  pinMode(pin_buttGND, OUTPUT);      // Определяем временный общий кнопок, как выход
  digitalWrite(pin_buttGND, LOW);    // и устанавливаем на нем низкий уровень
  pinMode(pin_butt_1, INPUT_PULLUP); // Определяем вывод кнопки 1, как вход и подтягиваем его внутренним резюком к VCC
  pinMode(pin_butt_2, INPUT_PULLUP); // Определяем вывод кнопки 2, как вход и подтягиваем его внутренним резюком к VCC
  pinMode(pin_butt_3, INPUT_PULLUP); // Определяем вывод кнопки 3, как вход и подтягиваем его внутренним резюком к VCC
  pinMode(pin_butt_4, INPUT_PULLUP); // Определяем вывод кнопки 4, как вход и подтягиваем его внутренним резюком к VCC
  //
#ifdef Debug
  pinMode(pin_ZeroOut, OUTPUT);       // Определяем вывод импульса ноля, как выход
  digitalWrite(pin_ZeroOut, LOW);     //
  pinMode(pin_DebugOut, OUTPUT);      // Определяем отладочный вывод, как выход
  digitalWrite(pin_DebugOut, LOW);    //
  pinMode(pin_TestOut, OUTPUT);       // Определяем отладочный вывод, как выход
  digitalWrite(pin_TestOut, LOW);     //
#endif
//
#ifdef LED_debug
  pinMode(LED_BUILTIN, OUTPUT);       // Определяем пин светодиода, как выход
  digitalWrite(LED_BUILTIN, LOW);     // 
#endif
//
}//========================Инициализация входов/выходов контроллера=========
//
void Razgon_() { //===========Подпрограмма обработки режима разгона================
  #define RELAY_SHUNTING_TIME 50                    // количество полупериодов, в течение которых шунтируются контакты реле
    if (fl.razg_on &&                               // Если включен разгон..
        !fl.TRelay &&                               // ..и НЕ включено контактное реле
        (++cnt.PPcount_R == RELAY_SHUNTING_TIME)) { // ..и все это длится уже более 500мс,
      fl.TRelay = 1; cnt.PPcount_R = 0;             // то включим контактное реле и обнулим счетчик
    }
    if (fl.razg &&                                  // Если включен максимум для твердотельного реле..
        !fl.razg_on &&                              // ..и выключен разгон
        (++cnt.PPcount_R == RELAY_SHUNTING_TIME)) { // ..и все это длится уже более 500мс,
      fl.razg = 0; cnt.PPcount_R = 0;               // то выключим реле и обнулим счетчик
    }
}//===========Подпрограмма обработки режима разгона================
//
void PDM_() { //===========Подпрограмма управления твердотельным реле ТЭНа================
  if (fl.razg) {
    pdm = CICLE; // В режиме разгона твердотельное всегда открыто
  }
  lev = pdm + err;                // Текущий уровень с учетом ошибки дискретизации, сделанной на предыдущем полупериоде.
  //Текущее значение постоянной составляющей
  if (fl.PVolna) ps -= fl.Tout; // Декрементируем ps, если в прошлую отрицательную полуволну твердотельное реле было включено
  else ps += fl.Tout;           // Инкрементируем ps, если в прошлую положительную полуволну твердотельное реле было включено
//
  if ((lev >= CICLE/2) && ((ps == 0) || (fl.PVolna && (ps < 0)) || (!fl.PVolna && (ps > 0)))) { // Ставим флаг включения ТЭНа с учетом значения постоянной составляющей
    fl.Tout = 1; err = lev - CICLE;         // и считаем ошибку для следующего полупериода
  }        
  else {
    fl.Tout = 0; err = lev;                 // Снимаем флаг включения ТЭНа и считаем ошибку
  }
}//========================Подпрограмма управления твердотельным реле ТЭНа================
//
void Buttons_() { //==============Опрос кнопок=====================
  static struct buttons {
    unsigned butt : 4;      // код текущей нажатой кнопки
    unsigned last_butt : 4; // код предыдущей нажатой кнопки
    unsigned butt_1 : 1;    // текущее состояние кнопки (0 - не нажата)
    unsigned butt_2 : 1;    // текущее состояние кнопки
    unsigned butt_3 : 1;    // текущее состояние кнопки
    unsigned butt_4 : 1;    // текущее состояние кнопки
    unsigned no_select : 1; // вспомогательный флажок для начального меню
    unsigned writePnom : 1; // вспомогательный флажок записи нового Pnom в EEPROM
    unsigned clear_old : 1; // вспомогательный флажок стирания старой уставки из EEPROM
  } bt ={}; // Инициализируем структуру с нулевыми членами
  static uint8_t butt_count = 0;        // счетчик для устранения дребезга
  static uint8_t butt_force_count = 0;  // счетчик для форсирования инкремента/декремента
  //
  if (bt.clear_old) { //=====Стираем старую уставку, если нужно
    eeprom_update_byte((uint8_t*)clear_old_addr,0xff);  // Стираем самую старую уставку
    bt.clear_old = 0;                                   // Снимаем флажок стирания
  }
  bt.butt_1 = !digitalRead(pin_butt_1);
  bt.butt_2 = !digitalRead(pin_butt_2);
  bt.butt_3 = !digitalRead(pin_butt_3);
  bt.butt_4 = !digitalRead(pin_butt_4);
  byte button_sum = bt.butt_1 + bt.butt_2 + bt.butt_3 + bt.butt_4;
  if ( (button_sum == 0) && butt_force_count ) butt_force_count--; // уменьшаем счетчик форсирования инкремента/декремента
  if ( button_sum == fl.butt ) { // Или нажата одна кнопка или ни одной
    bt.butt = bt.butt_1 + (bt.butt_2 << 1) + (bt.butt_3 << 2) + (bt.butt_4 << 3);
    if ( bt.butt == bt.last_butt ) {
      butt_count++;
    }
    else {
      butt_count = 1;
      bt.last_butt = bt.butt;
    }
  }
  else if (--butt_count < 1) {
    butt_count = 1;
  }
  //
  if ( (butt_count == DEBOUNCE) || fl.dspTimeout ) {  // Есть нажатая кнопка или достаточная пауза после нажатия или таймаут выхода из меню
    if (bt.butt) {  // Если нажата кнопка, сбросим таймер ожидания выхода из меню
      cnt.menuWDT = 0;
    }
    switch (fl.dspMenu) { //=====Проверяем режимы меню
      case 2:  {  //=============Если мы в начальном меню выбора номинальной мощности, то...
        if (fl.dspTimeout) {                  // Если кнопки слишком долго не нажимались...
          if (Pnom_arr[0] != 0xffff) {        // и есть записанное значение, уходим
            cnt.Pnom_number = 0;              // 
            Pnom = Pnom_arr[cnt.Pnom_number]; // По умолчанию установим номинальную мощность из нулевой ячейки
            fl.writable = 1;                  // Уставки пишутся в EERPOM
            EEPROM_read_PDMs();               // Читаем уставки
            fl.uartUnhold = 1;                // Разрешим обращение к USART
            fl.dspMenu = 0;                   // Выйдем из менюшки
            fl.dspRefresh = 1;                // Ставим флаг обновления экрана
          }
          fl.dspTimeout = 0;                  // Снимаем флаг таймаута выхода из меню
          break;
        }
        switch (bt.butt) {
          case 1: { //-----Кнопкой "P-" перебираем записанные значения или уменьшаем значение Pnom
            if (bt.no_select) { //Если не выбираем, а вводим значение,...
              if (butt_force_count > 20) {      // Если очень долго держим...
                if (Pnom > 100) Pnom -= 100;    // Убавляем по соточке, пока есть куда
                else butt_force_count = 10;     // Если некуда убавлять - снижаем форсаж
              }
              else if (butt_force_count > 10) { // Если долго держим...
                if (Pnom > 10) Pnom -= 10;      // Убавляем по десяточке, пока есть куда
                else butt_force_count = 0;      // Если некуда убавлять - снижаем форсаж
              }
              else {
                if (--Pnom == 0) Pnom=1;        // Убавляем по чуть-чуть
              }
            }
            else {  //Если выбираем из записанных в EEPROM...
              if (++cnt.PDMcount > cnt.Pnom_count) cnt.PDMcount=0; // Перебираем значения уставок мощности ТЭНа
              Pnom = Pnom_arr[cnt.PDMcount];
            }
            butt_force_count++;
            break;                      //Закончили
          }
          case 2: { //-----Кнопкой "P+" увеличиваем значение Pnom
            if (butt_force_count > 20) {
              if ((Pnom += 100) > 9999) Pnom=9999;// Если очень долго держим, прибавляем по соточке
            }
            else if (butt_force_count > 10) {
              if ((Pnom += 10) > 9999) Pnom=9999; // Если долго держим, прибавляем по десяточке
            }
            else {
              if (++Pnom > 9999) Pnom=9999;       // Прибавляем по чуть-чуть
            }
            bt.no_select = 1;
            butt_force_count++;
            break;                      //Закончили
          } 
          case 4: { //-----Кнопкой "Стоп" пишем значение в память и выходим из менюшки
            bt.writePnom = 1; // Ставим флаг записи нового значения Pnom в EEPROM
            fl.writable = 1;  // Ставим флаг записи уставок в EEPROM
          }
          case 8: { //-----Кнопкой "Разгон" выходим из менюшки
            if (Pnom < 10000) { // Если значение реальное...
              cnt.Pnom_number = cnt.PDMcount;               // Запомним порядковый номер выбранного Pnom
              if (bt.no_select) {                           // Если значение НЕ выбрано из записанных в EEPROM, а введено...
                for (int x = cnt.Pnom_count; x >= 0; x--) { // Проверим новое значение на совпадение с уже записанными
                  if (Pnom == Pnom_arr[x]) {                // Если такое значение уже есть в EEPROM...
                    cnt.Pnom_number = x;                    // Запомним порядковый номер совпавшего Pnom
                    bt.writePnom = 0;                       // Снимем флаг записи нового значения Pnom в EEPROM
                    fl.writable = 1;                        // Ставим флаг записи уставок в EEPROM
                    break;
                  }
                }
              }
              else {                                        // Если значение выбрано из записанных в EEPROM...
                bt.writePnom = 0;                           // Снимем флаг записи нового значения Pnom в EEPROM
                fl.writable = 1;                            // Ставим флаг записи уставок в EEPROM
              }
              //
              cnt.PDMcount=0;                               //Сбрасываем счетчик
              //
              if (fl.writable) {                            // Если уставки пишутся в EERPOM, то
                EEPROM_read_PDMs();                         // читаем ранее записанное
              }
              if (bt.writePnom) { // Запишем новое значение Pnom, если необходимо
                eeprom_update_word((uint16_t*)(cnt.Pnom_number * 2),Pnom);
                bt.writePnom = 0; // и сбросим флаг записи нового значения Pnom
              }
              fl.dspMenu = 0;   //Снимаем флаг перехода в меню
              //
              #ifdef USE_USART      //========================================
                fl.uartUnhold = 1;  // Разрешим обращение к USART
              #endif                //========================================
              fl.dspRefresh = 1;//Ставим флаг обновления экрана
            }
            fl.butt = 0;        //После нажатия должна быть пауза
            break;              //Закончили
          }
          default:
            fl.butt = 1;        // достаточная пауза между нажатиями
        }
        break;
      }
      case 1:  {  //=============Если мы в меню выбора уставки, то...
        if (fl.dspTimeout) {  // Если кнопки слишком долго не нажимались, уходим
          fl.dspMenu = 0;     // Выйдем из менюшки
          fl.dspRefresh = 1;  // Ставим флаг обновления экрана
          fl.dspTimeout = 0;  // Снимаем флаг таймаута выхода из меню
          break;
        }
        switch (bt.butt) {
          case 1: { //=====По кнопке "Р-" перебираем значения
            if (++cnt.PDMcount > PDMset_SIZE - 1) cnt.PDMcount=0; //Перебираем значения уставок мощности ТЭНа
  //          fl.butt = 0;            //После нажатия должна быть пауза          
            break;                    //Закончили
          }
          case 2: { //=====По кнопке "Р+" перебираем значения
            if (cnt.PDMcount-- == 0) cnt.PDMcount=PDMset_SIZE - 1;//Перебираем значения уставок мощности ТЭНа
  //          fl.butt = 0;            //После нажатия должна быть пауза          
            break;                    //Закончили
          }
          case 4: { //=====По кнопке "стоп" записываем уставку, если нужно, принимаем и выходим
            PDMust = PDMset[0][cnt.PDMcount];//Устанавливаем выбранную мощность ТЭНа
            if (fl.writable) {  // Если уставки запоминаются...
              if (!PDMset[1][cnt.PDMcount]) { // Если просят записать НЕ уже записанное...
                eeprom_update_byte((uint8_t*)new_addr,PDMset[0][cnt.PDMcount]); // Пишем новую уставку
                PDMset[1][cnt.PDMcount] = new_addr; // Заносим в массив адрес свежезаписанной уставки
                if (++new_addr > end_addr) new_addr = start_addr; // Инкрементируем адрес для новой уставки и следим, чтобы не выходило за границы области
                if (cnt.PDMcount == PDMset_SIZE - 1) {  // Если новое значение - последнее в списке
                  //
                  if (!old_addr) {  // Если в массиве уставок есть незаписанные в EEPROM значения, то сначала стираем их
                    boolean swapped = 1; int upper_index = PDMset_SIZE - 1; //=====Пузырьковая сортировка
                    while (swapped) {                                       // Пока есть обмены, сортируем
                      swapped = 0;
                      for (int i = 1; i < upper_index; i++) {
                        if (PDMset[1][i] < PDMset[1][i - 1]) {
                          uint16_t k = PDMset[1][i];
                          PDMset[1][i] = PDMset[1][i - 1];
                          PDMset[1][i - 1] = k;
                          uint8_t m = PDMset[0][i]; 
                          PDMset[0][i] = PDMset[0][i - 1];
                          PDMset[0][i - 1] = m;
                          swapped = 1;
                        }
                      }
                      upper_index--;
                    } //=====Закончили сортировку
                    old_addr = PDMset[1][0];  // Обновляем адрес самой старой уставки
                  }
                  //
                  if (old_addr) {           // Если в массиве уставок все значения записаны в EEPROM, то стираем самое старое
                    bt.clear_old = 1;       // Ставим флажок стирания (сотрём в следующий вызов подпрограммы опроса кнопок)
                    clear_old_addr = old_addr; // Плодим сущности без устали!
                  }
                  //
                  uint8_t k = PDMset[0][0];
                  for (int x = 0; x < PDMset_SIZE - 1; x++) { // Сдвинем массив
                    PDMset[0][x] = PDMset[0][x + 1];
                    PDMset[1][x] = PDMset[1][x + 1];
                  }
                  //
                  PDMset[0][PDMset_SIZE - 1] = k; // Запишем во временную ячейку свежеудаленное значение
                  PDMset[1][PDMset_SIZE - 1] = 0;
                  cnt.PDMcount--;
                  old_addr = PDMset[1][0];    // Обновляем адрес самой старой уставки
                  //
                }
              }
            }
            fl.dspMenu = 0;           //Снимаем флаг перехода в меню
            fl.dspRefresh = 1;        //Ставим флаг обновления экрана
            fl.butt = 0;              //После нажатия должна быть пауза
            break;                    //Закончили
          }
          case 8: { //=====По кнопке "разгон" принимаем и выходим
            PDMust = PDMset[0][cnt.PDMcount];//Устанавливаем выбранную мощность ТЭНа
            fl.dspMenu = 0;           //Снимаем флаг перехода в меню
            fl.dspRefresh = 1;        //Ставим флаг обновления экрана
            fl.butt = 0;              //После нажатия должна быть пауза
            break;                    //Закончили
          }
          default:
            fl.butt = 1;              // достаточная пауза между нажатиями
        }
        break;
      }
      default: {  //=============А если не в меню, то...
        switch (bt.butt) {
          case 1:
            if (PDMust > 0) PDMust--;    //Уменьшаем установленную мощность
            break;
          case 2:
            if (PDMust < CICLE) PDMust++; //Увеличиваем установленную мощность
            break;
          case 4:
            if (PDMust == 0) {    //Если мы не в меню и мощность ТЭНа нулевая, то...
              fl.dspMenu = 1;     //Ставим флаг перехода в меню
              fl.dspRefresh = 1;  //Ставим флаг обновления экрана
            }
            else {                //Если мы не в меню и мощность ТЭНа НЕнулевая, то...
                int y = 0;
                for (int x = PDMset_SIZE - 1; x >= 0; x--) {  // Проверим новое значение на совпадение с уже записанными
                  if (PDMust == PDMset[0][x]) {
                    y = 1; break;
                  }
                }
                if (!y) { // Если новое значение действительно новое, то...
                  PDMset[0][PDMset_SIZE - 1] = PDMust;  //Запоминаем текущую мощность ТЭНа
                  PDMset[1][PDMset_SIZE - 1] = 0;       //Адрес зануляем на всякий случай
                  cnt.PDMcount = PDMset_SIZE - 1;       //Ставим счетчик на запомненную уставку
                }
                PDMust = 0;         //Экстренно выключаем ТЭН
                fl.razg_on = 0;     //Выключаем разгон
                fl.TRelay = 0;      //Выключаем контактное реле
            }
            fl.butt = 0;          //После нажатия должна быть пауза
            break;                
          case 8:
            fl.razg_on = ((!fl.NotZero) & (!fl.Udown) & (!fl.razg_on)); //Триггер режима разгона (гистерезис организован в обработке начала полупериода)
            fl.razg |= fl.razg_on;                      //Если разгон включили, то твердотельное реле на максимум сразу
            fl.TRelay &= fl.razg_on;                    //Если разгон выключили, то контактное реле выключаем сразу
            fl.butt = 0;                                //После нажатия должна быть пауза
            break;
          default:
            fl.butt = 1;  // достаточная пауза между нажатиями
        }
      }
    }
    butt_count = 1;
    bt.butt = 0;
    set_Pust();         // Пересчитаем Pust
    fl.DisplayOut = 1;  //Обновление информации на дисплее
  }
} //================================Опрос кнопок=====================
//
//
//ISR(USART_RX_vect) { //======Обработчик приема управляющих сигналов по USART=========
//} //==========================Обработчик приема управляющих сигналов по USART=========

ISR(TIMER2_COMPA_vect) { //======Обработчик начала очередного полупериода по таймеру2=========
  //
  #ifdef Debug
    PORTD ^=  (1 << pin_TestOut); //ОТЛАДКА
  #endif
  //
  Razgon_();
  if (pdm) PDM_();  // Не будем зря теребить подпрограмму, если pdm = 0
  else fl.Tout = 0;
//
  fl.PVolna = !fl.PVolna; // Инвертируем флаг полуволны
  fl.PP = 1;              // Ставим флаг окончания очередного полупериода
  OCR2A = PID_ust;        // Грузим новое значение в регистр сравнения
//
#ifdef High_level_triac // управление твердотельным реле высоким уровнем
  if (fl.Tout) {
    PORTD |=  (1 << pin_TOut); // Включаем ТЭН
  }
  else {
    PORTD &=  ~(1 << pin_TOut); // Выключаем ТЭН
  }
#else // управление твердотельным реле низким уровнем
  if (fl.Tout) {
    PORTD &=  ~(1 << pin_TOut); // Включаем ТЭН
  }
  else {
    PORTD |=  (1 << pin_TOut); // Выключаем ТЭН
  }
#endif
//
#ifdef High_level_relay // управление контактным реле высоким уровнем
  if (fl.TRelay) {
    PORTD |=  (1 << pin_TRelay); // Включаем ТЭН
  }
  else {
    PORTD &=  ~(1 << pin_TRelay); // Выключаем ТЭН
  }
#else // управление контактным реле низким уровнем
  if (fl.TRelay) {
    PORTD &=  ~(1 << pin_TRelay); // Включаем ТЭН
  }
  else {
    PORTD |=  (1 << pin_TRelay); // Выключаем ТЭН
  }
#endif
//
#ifdef LED_debug
  if (fl.Tout) {  // Продублируем сигнал управления твердотелкой на светодиоде
    digitalWrite(LED_BUILTIN, HIGH);  // 
  }
  else {
    digitalWrite(LED_BUILTIN, LOW);   // 
  }
#endif
  //
sei(); // разрешим прерывания
  // Считаем время
  if (++cnt.Pcount_tm == P_TIME_MAX) {  // Уже секунду суммируем
    cnt.Pcount_tm = 0;
    if ((fl.dspMenu > 0) && (++cnt.menuWDT == MENU_TIMEOUT)) {  // Если мы в меню и слишком долго не жмутся кнопки
      fl.dspTimeout = 1;                                        // Установим флаг таймаута
      cnt.menuWDT = 0;                                          // Сбросим таймер ожидания выхода из меню
    }
    //
    #ifdef USE_USART
      if (++cnt.uartWDT == 10) {  // Если прошло уже 10 секунд от начала приема посылки по USART
        fl.uartTimeout = 1;       // Установим флаг таймаута ожидания окончания посылки
        cnt.uartWDT = 0;          // Сбросим таймер ожидания окончания посылки
      }
    #endif
    #ifdef USE_ADprotocol
      fl.uartReport = 1;          // пора слать рапорт
    #endif
    //
  }
//
  Buttons_();   // Опрашиваем кнопки
}//==============================Обработчик начала очередного полупериода по таймеру2=========
//------------------------------------------------------------------------------
ISR(TIMER0_COMPA_vect) { //======Обработчик запуска преобразования АЦП по таймеру0=========
  ADCSRA |=  (1 << ADSC); // Запуск преобразования
}//==============================Обработчик запуска преобразования АЦП по таймеру0=========
//------------------------------------------------------------------------------
ISR(ADC_vect) { //===============Обработчик окончания преобразования АЦП===================
#ifdef Debug
  PORTD |=  (1 << pin_DebugOut);  //ОТЛАДКА
#endif
  static uint8_t   Pcount_sc = 0; // счетчик периодов, за которые просуммированы квадраты отсчетов
  register int32_t temp_32;
  register uint16_t U_adc;
  U_adc = ADCL; U_adc |= ((uint16_t)ADCH) << 8; // забрали результат преобразования АЦП
  register uint8_t TM2_current;
  TM2_current = TCNT2;                      // забрали значение из таймера синхронизации с сетью
  register int16_t U;
  U = 0;
  if (U_adc >= U_ZERO) {
    U_adc -= U_ZERO;  // Убираем постоянную составляющую из оцифрованного сигнала
    U += U_adc;
  }
  else {
    U_adc = U_ZERO - U_adc;
    U -= U_adc;
  }
  //===детекция перехода через ноль и ПИД-синхронизация=================================
  Udelta += (U - Uold);       //
  U = Udelta >> 5;          //КИХ ФНЧ 1-го порядка с коэффициентом 1/32
  //  U = (1*Udelta)/32;          //КИХ ФНЧ 1-го порядка с коэффициентом 1/32
  if ((!fl.zero) && (U >= 0) && (Uold <= 0) && (U != Uold)) { //=======переход через ноль детектед=======
#ifdef Debug
    PORTD |=  (1 << pin_ZeroOut);
#endif
   sc_notzero = 0;    // Обнуляем счетчик выборок АЦП без перехода через ноль
   fl.NotZero = 0;    // Снимаем флажок отсутствия детекции перехода через ноль
  //===Проверка насуммированных отсчетов============================
    if (++Pcount_sc == PSUM_MAX) {          // Насуммировали достаточно
    U_sum = sum; fl.sum = 1; sc_sum = sc;   // Насуммированное готово к обработке
    sc = 0; sum = 0; Pcount_sc = 0;         // Сбрасываем счетчик, сумматор и счетчик полупериодов
  }
  //===Проверка насуммированных отсчетов============================
    fl.zero = 1;
    temp_32 = (TM2_current + Phase) << Km;      // Разность фаз
//    if (PVolna == (-1)) {
    if (!fl.PVolna) {
      temp_32 = temp_32 - PID_reg - (1 << Km);  // Разность фаз должна быть с соответствующим знаком
    }
    PID_int += (temp_32 >> Ki);                 // Считаем интегральную составляющую
    PID_reg += temp_32 >> Kp;                   // Считаем новую функцию управления
    PID_reg += PID_int;
    PID_reg += ( temp_32 - PID_err_old ) >> Kd;
    PID_err_old = temp_32;
    // Готовим данные для записи в регистр сравнения таймера 2
      if ( PID_reg > (T_max << Km)) {
        PID_reg = (T_max << Km);  // Ограничим сверху
      }
      else if ( PID_reg < (T_min << Km)) {
          PID_reg = (T_min << Km);  // Ограничим снизу
        }
      temp_32 = PID_reg >> (Km - 1);  // ...и правильно округлим
      temp_32++;                      // используя уже не нужную в этой подпрограмме
      PID_ust = temp_32 >> 1;         // переменную temp_32
      //
    }
 //
  else { //=======переход через ноль  NOT детектед=======
    fl.zero = 0;
    if (++sc_notzero == ZSUM_MAX) {   // Насуммировали достаточно
      fl.NotZero = 1; sc_notzero = 0;
      PID_ust = LINE_FREQ;
      fl.razg_on = 0;       //выключим режим разгона
      pdm = 0; fl.Tout = 0; //выключим твердотельное реле
      fl.TRelay = 0;        //выключим контактное реле
      U_real = 0; sc = 0; sum = 0; Pcount_sc = 0; // Обнулим счетчик, сумматор, счетчик полупериодов и значение напряжения
      fl.DisplayOut = 1;
    }
   //
#ifdef Debug
    PORTD &=  ~(1 << pin_ZeroOut);
#endif
  }
  //
  Uold = U;                   //
  //===детекция перехода через ноль и ПИД-синхронизация=================================
  //
  sei(); // Следующие фрагменты длительны, но не требуют атомарности; разрешим прерывания
  //===Суммирование квадратов=======================================
  temp_32 = U_adc * U_adc;  // Возводим в квадрат выборку АЦП (используем всё ту же переменную temp_32)
  sum += temp_32;           // Суммирование квадратов выборок АЦП
  ++sc;                     // Счетчик выборок АЦП
  //===Суммирование квадратов=======================================
  //
#ifdef Debug
  PORTD &=  ~(1 << pin_DebugOut); //ОТЛАДКА
#endif
}//===============================Обработчик окончания преобразования АЦП===================
//
void setup() {
// 
  fl.dspMenu = 2; // Сначала - начальное меню
  Pins_init();    // Инициализируем входы/выходы
  ADC_init();     // Инициализируем АЦП
  Timers_init();  // Инициализируем таймеры
  sei();          // Разрешаем глобальные прерывания
  //
  pp_Delay(20);   // Подождем 20 полупериодов
//
#ifdef DisplayReset
  digitalWrite(pin_OLED_res, HIGH); // Разрешаем работу дисплея
#endif
//
  pp_Delay(10);   // Подождем 10 полупериодов для гарантированного разрешения
  //
  ASOled.init();                        // Инициализируем OLED дисплей
  //
  #ifdef LOGO
  ASOled.clearDisplay();                // Очищаем, иначе некорректно работает для дисплеев на SH1106 (косяк библиотеки)
  ASOled.drawBitmap(logo, 0, 0, 128, 8);// Даём заставочку
  pp_Delay(400);                        // Подождем 500 полупериодов, пережидаем переходные процессы и любуемся заставкой
  #endif
  //
  ASOled.clearDisplay();                // Очищаем, иначе некорректно работает для дисплеев на SH1106 (косяк библиотеки)
  ASOled.printString_6x8(F("Стабилизатор мощности"), X_centred (21), 0);
  ASOled.printString_6x8(F("ТЭНа"), X_centred (4), 1);
  ASOled.printString_6x8(F(VERSION), X_centred (VERSION_LEN), 3);
  ASOled.printString_6x8(F("JohnJohnov"), X_centred (10), 5);
  ASOled.printString_6x8(F("alcodistillers.ru"), X_centred (17), 7);
  //
  EEPROM_read_Pnoms();  // Прочитаем из EEPROM записанные номиналы ТЭНов
  //
  pp_Delay(800);        // Подождем 600 полупериодов, пережидаем переходные процессы и любуемся заставкой
  //
  ASOled.clearDisplay();
  fl.dspRefresh = 1;

#ifdef USE_USART//++++++++++++++++USART initialization++++++++++++++++++++++++++++
//Если задействовано управление регулятором ТЭНа через UART, инициализируем оный
//
USART_start();
//
#endif // USE_USART
}
//
void loop() {
// 
  if (fl.sum) { //==========Обработка данных от АЦП и корректировка выдаваемой мощности============
#ifdef NOT_LM358
    // 0,55 - Коэффициент нормирования ((380/512)^2, 380В максимальное амплитудное) для Rail-to-Rail операционника
    U_sum /= sc_sum;    //Ненормированный квадрат среднеквадратичного
    U_sum *= 0.55;      //Нормированный квадрат среднеквадратичного
#else
    // 3 - Коэффициент нормирования ((380/220)^2, 380В максимальное амплитудное) для стандартно установленного LM358
    U_sum *= 3;         //Нормированная сумма квадратов среднеквадратичного
    U_sum /= sc_sum;    //Нормированный квадрат среднеквадратичного
#endif
    //=====Корректируем pdm
    register uint32_t tmp; // Величины великоваты, чтобы попасть в размерность приходится считать аккуратно
    //    pdm = U_LINE_Q*PDMust/(U_sum);
    tmp = U_LINE_Q << 1;
    tmp *= PDMust;
    tmp /= U_sum;
    tmp++;
    tmp = tmp >> 1;
    //
    if (tmp > CICLE || fl.razg) { // Следим, чтобы pdm не превышала CICLE
      pdm = CICLE;
      fl.Ulow = !fl.razg; // Или напряжение сети не позволяет выдать установленный уровень мощности, или разгон
    }
    else {
      fl.Ulow = 0;
      pdm = tmp;
    }
    // Проверяем величину напряжения
    U_sum *= 400;               // Произведем некоторое математическое колдунство, 
    U_sum = sqrt(U_sum);        // чтобы получить один знак после запятой без float
    U_sum++; U_sum = U_sum >> 1;// и с правильным округлением.
    U_real_dec = U_sum % 10;    // Среднеквадратичное (дробная часть)
    U_real = U_sum / 10;        // Среднеквадратичное (целая часть)
    //
    // Контролируем значение
    if ( U_real < U_MIN ) { //Действующее напряжение сети ниже U_MIN - отключим ТЭН (авария)
      fl.Udown = 1;       //поставим флажок низкого сетевого
      fl.razg_on = 0;     //выключим режим разгона
      pdm = 0;            //выключим твердотельное реле
      fl.TRelay = 0;      //выключим контактное реле
    }
    else {
      fl.Udown = 0;
    }
    fl.sum = 0;
    fl.DisplayOut = 1;  //Обновление информации на дисплее
  } //======================Обработка данных от АЦП и корректировка выдаваемой мощности============
  //
  #ifdef USE_ADprotocol
  if (fl.uartReport && fl.uartUnhold) {  //==========Отправка отчета внешнему контроллеру============
    USART_report();
    fl.uartReport = 0;
  } //=========================Отправка отчета внешнему контроллеру============
  #endif
  //
  if (fl.DisplayOut) { //========================Вывод информации на дисплей=============  
    switch (fl.dspMenu) { //=====Проверяем режимы меню
      case 2:  {  //=============Если мы в начальном меню, то...
        if (fl.dspRefresh) {  //Обновляем дисплей
          ASOled.clearDisplay();
          ASOled.printString_6x8(F("Выберите/введите Pном"), 0, 0);
          ASOled.printString_6x8(F("Pном=      Вт, (230В)"), 0, 1);
          ASOled.printString_6x8(F("---------------------"), 0, 2);
          ASOled.printString_6x8(F(" Управление:"), 0, 3);
          ASOled.printString_6x8(F("P- Выбор/уменьшение"), 0, 4);
          ASOled.printString_6x8(F("P+ Увеличение"), 0, 5);
          ASOled.printString_6x8(F("Ст Принять и записать"), 0, 6);
          ASOled.printString_6x8(F("Рз Принять без записи"), 0, 7);
        }
        static uint16_t Pnomold = 0;
        if (!Pnom || Pnom > 9999) {
          Pnomold = Pnom;
          ASOled.printString_6x8(F("****"), X_position (6), 1);
        }
        else if ((Pnomold != Pnom) || fl.dspRefresh) {
          Pnomold = Pnom;
          ASOled.printString_6x8(F("    "), X_position (6), 1);
          ASOled.printNumber((long)Pnom, X_position (9,Pnom), 1);
        }
        fl.dspRefresh = 0;
        break;
      }
      case 1:  {  //=============Если мы в меню выбора уставки, то...
        if (fl.dspRefresh) {  //Обновляем дисплей
          ASOled.clearDisplay();
          ASOled.printString_6x8(F("Выберите уставку"), 0, 0);
          ASOled.printString_6x8(F("Pуст=      Вт"), 0, 1);
          ASOled.printString_6x8(F("---------------------"), 0, 2);
          ASOled.printString_6x8(F(" Управление:"), 0, 3);
          ASOled.printString_6x8(F("P- Выбор"), 0, 4);
          ASOled.printString_6x8(F("P+ Выбор"), 0, 5);
          if (fl.writable) {  // Если уставки пишутся в EEPROM, то...
            ASOled.printString_6x8(F("Ст Принять и записать"), 0, 6);
          }
          else {  // а если уставки не пишутся в EEPROM, то...
            ASOled.printString_6x8(F("Ст Принять без записи"), 0, 6);
          }
          ASOled.printString_6x8(F("Рз Принять без записи"), 0, 7);
        }
        static uint8_t PDMold = 0;
        if ((PDMold != PDMset[0][cnt.PDMcount]) || fl.dspRefresh) {
          PDMold = PDMset[0][cnt.PDMcount];
          uint32_t p = Pnom << 1; p *= PDMold; p /= CICLE;  p++; p = p >> 1; // Считаем уставку с округлением
          ASOled.printString_6x8(F("    "), X_position (6), 1);
          ASOled.printNumber((long)p, X_position (9,p), 1);
          if (PDMset[1][cnt.PDMcount]) {  // Если значение записано в EEPROM
            ASOled.printString_6x8(F("R"), X_position (20), 1);   // Поставим значок
          }
          else ASOled.printString_6x8(F(" "), X_position (20), 1);// а если не записано - уберем
        }
        fl.dspRefresh = 0;
        break;
      }
      default: {  //=============А если не в меню, то...
        #define str_Ureal 0
        #define str_Ustat 1
        #define str_ust 3
        #define str_Pnom 6
        #define str_Razgon 4
        #define str_Relay 7
        //
        if (fl.dspRefresh) {  //Обновляем дисплей
          ASOled.clearDisplay();
          ASOled.printString_6x8(F("Напр.сети        ,  В"), 0, str_Ureal);
          ASOled.printString_6x8(F("Pуст      Вт;    ,  %"), 0, str_ust);
          ASOled.printString_6x8(F("Pном      Вт"), 0, str_Pnom);
          ASOled.printNumber((long)Pnom, X_position (8,Pnom), str_Pnom);
        }
        //
        static uint16_t U_real_old = 0;
        if ((U_real_old != U_real) || fl.dspRefresh) {
          U_real_old = U_real;
          ASOled.printString_6x8(F("    "), X_position (13), str_Ureal);
          ASOled.printNumber((long)U_real_old, X_position (16,U_real_old), str_Ureal);
        }
        static uint8_t U_real_dec_old = 0;
        if ((U_real_dec_old != U_real_dec) || fl.dspRefresh) {
          U_real_dec_old = U_real_dec;
          ASOled.printNumber((long)U_real_dec_old, X_position (18), str_Ureal);
        }
        static uint16_t Pust_old = 0;
        if ((Pust_old != Pust) || fl.dspRefresh) {
          Pust_old = Pust;
          ASOled.printString_6x8(F("    "), X_position (5), str_ust);
          ASOled.printNumber((long)Pust_old, X_position (8,Pust_old), str_ust);
        }
        //
        static uint8_t PDMust_old = 0;
        if ((PDMust_old != PDMust) || fl.dspRefresh) {
          PDMust_old = PDMust;
          ASOled.printString_6x8(F("    "), X_position (13), str_ust);
          ASOled.printNumber((long)(PDMust_old/2), X_position (16,(PDMust_old/2)), str_ust);
          ASOled.printNumber((long)(PDMust_old & 1)*5, X_position (18), str_ust);  
        }
        fl.dspRefresh = 0;
        //
        if (fl.Udown || fl.NotZero) {
          ASOled.printString_6x8(F("-----Авария сети-----"), 0, str_Ustat);
        }
        else if (fl.Ulow) {
          ASOled.printString_6x8(F("--Недост.напр. сети--"), 0, str_Ustat);
        }
        else {
          ASOled.printString_6x8(F("---------------------"), 0, str_Ustat);
        }
      //
        if (fl.razg_on) {
          static uint8_t count_1 = 0;
          byte x1 = 5 - count_1;
          byte x2 = 20 - x1;
          ASOled.printString_6x8(F("------<Разгон!>------"), 0, str_Razgon);
          ASOled.printString_6x8("<", X_position (x1), str_Razgon);
          ASOled.printString_6x8(">", X_position (x2), str_Razgon);
          if (++count_1 > 5) count_1 = 0;
        }
        else {
          ASOled.printString_6x8(F("---------------------"), 0, str_Razgon);
        }
        //
        if (fl.TRelay) {
          ASOled.printString_6x8(F("Реле включено"), X_position (0), str_Relay);
        }
        else {
          ASOled.printString_6x8(F("             "), X_position (0), str_Relay);
        }
      }
    }
  //
      fl.DisplayOut = 0;
 }//========================Вывод информации на дисплей=============  
  //
  #ifdef USE_USART
  if (fl.uartUnhold) {
  USART_parser();
  }
  #endif
}
//
